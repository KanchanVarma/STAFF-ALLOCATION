"use strict";
// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const casbin_1 = require("casbin");
const sequelize_typescript_1 = require("sequelize-typescript");
const casbinRule_1 = require("./casbinRule");
function ModelFactory(model) {
    return class extends model {
    };
}
/**
 * SequelizeAdapter represents the Sequelize adapter for policy storage.
 */
class SequelizeAdapter {
    constructor(connStr, dbSpecified) {
        this.connStr = connStr;
        this.dbSpecified = dbSpecified;
    }
    /**
     * newAdapter is the constructor.
     * dbSpecified is an optional boolean parameter. The default value is false.
     * It's up to whether you have specified an existing DB in connStr.
     * If dbSpecified == true, you need to make sure the DB in connStr exists.
     * If dbSpecified == false, the adapter will automatically create a DB named 'casbin'.
     */
    static newAdapter(connStr, dbSpecified = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const a = new SequelizeAdapter(connStr, dbSpecified);
            yield a.open();
            return a;
        });
    }
    createDatabase() {
        return __awaiter(this, void 0, void 0, function* () {
            const uriConfig = {
                url: this.connStr,
                logging: false,
                pool: { max: 5, min: 0, idle: 10000 }
            };
            const sequelize = new sequelize_typescript_1.Sequelize(uriConfig);
            yield sequelize.authenticate();
            yield sequelize.query('CREATE DATABASE IF NOT EXISTS casbin');
            yield sequelize.close();
        });
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.connStr;
            if (!this.dbSpecified) {
                url = this.connStr + 'casbin';
                yield this.createDatabase();
            }
            const uriConfig = {
                url,
                logging: false,
                pool: { max: 5, min: 0, idle: 10000 }
            };
            this.sequelize = new sequelize_typescript_1.Sequelize(uriConfig);
            yield this.sequelize.authenticate();
            const Rule = ModelFactory(casbinRule_1.CasbinRule);
            SequelizeAdapter.modelMap.set(this.sequelize, Rule);
            this.sequelize.addModels([Rule]);
            yield this.createTable();
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sequelize.close();
        });
    }
    getCasbinRuleModel() {
        const model = SequelizeAdapter.modelMap.get(this.sequelize);
        return !model ? casbinRule_1.CasbinRule : model;
    }
    createTable() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getCasbinRuleModel().sync();
        });
    }
    dropTable() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getCasbinRuleModel().destroy({ where: {}, truncate: true });
        });
    }
    loadPolicyLine(line, model) {
        const result = line.ptype + ', ' + [line.v0, line.v1, line.v2, line.v3, line.v4, line.v5].filter(n => n).join(', ');
        casbin_1.Helper.loadPolicyLine(result, model);
    }
    /**
     * loadPolicy loads all policy rules from the storage.
     */
    loadPolicy(model) {
        return __awaiter(this, void 0, void 0, function* () {
            const lines = yield this.getCasbinRuleModel().findAll();
            for (const line of lines) {
                this.loadPolicyLine(line, model);
            }
        });
    }
    savePolicyLine(ptype, rule) {
        const Rule = this.getCasbinRuleModel();
        const line = new Rule();
        line.ptype = ptype;
        if (rule.length > 0) {
            line.v0 = rule[0];
        }
        if (rule.length > 1) {
            line.v1 = rule[1];
        }
        if (rule.length > 2) {
            line.v2 = rule[2];
        }
        if (rule.length > 3) {
            line.v3 = rule[3];
        }
        if (rule.length > 4) {
            line.v4 = rule[4];
        }
        if (rule.length > 5) {
            line.v5 = rule[5];
        }
        return line;
    }
    /**
     * savePolicy saves all policy rules to the storage.
     */
    savePolicy(model) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.dropTable();
            yield this.createTable();
            let astMap = model.model.get('p');
            // @ts-ignore
            for (const [ptype, ast] of astMap) {
                for (const rule of ast.policy) {
                    const line = this.savePolicyLine(ptype, rule);
                    yield line.save();
                }
            }
            astMap = model.model.get('g');
            // @ts-ignore
            for (const [ptype, ast] of astMap) {
                for (const rule of ast.policy) {
                    const line = this.savePolicyLine(ptype, rule);
                    yield line.save();
                }
            }
            return true;
        });
    }
    /**
     * addPolicy adds a policy rule to the storage.
     */
    addPolicy(sec, ptype, rule) {
        return __awaiter(this, void 0, void 0, function* () {
            const line = this.savePolicyLine(ptype, rule);
            yield line.save();
        });
    }
    /**
     * removePolicy removes a policy rule from the storage.
     */
    removePolicy(sec, ptype, rule) {
        return __awaiter(this, void 0, void 0, function* () {
            const line = this.savePolicyLine(ptype, rule);
            const where = {};
            Object.keys(line.dataValues)
                .filter(key => key !== 'id')
                .forEach(key => {
                // @ts-ignore
                where[key] = line[key];
            });
            // @ts-ignore
            yield this.getCasbinRuleModel().destroy({ where });
        });
    }
    /**
     * removeFilteredPolicy removes policy rules that match the filter from the storage.
     */
    removeFilteredPolicy(sec, ptype, fieldIndex, ...fieldValues) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
SequelizeAdapter.modelMap = new Map();
exports.SequelizeAdapter = SequelizeAdapter;
